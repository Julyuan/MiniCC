#代码优化

报告人：赵竟霖

[TOC]

##一. 中间代码优化
###1.1 常数折叠
&ensp;&ensp;&ensp;在由语法树转化为中间代码的过程中,进行常数折叠,亦即在编译期间处理出一定能够计算出来的常数表达式的值,如:
``` cpp
int a;
a=1+2+3;
```
&ensp;&ensp;&ensp;生成中间代码的时候未经优化会被解释为类似下方四元式的中间代码
(注意,**四元式的第一个参数表示运算符,第二三个表示操作数,即右值,最后一个表示目标位置,即左值**):
``` python
("+",1,2,temp_var_8)
("+",temp_var_8,3,temp_var_4)
(":=",temp_var_4,None,a)
```
&ensp;&ensp;&ensp;"temp_var_"开头的表示编译器自动生成的中间变量,它们会占用栈空间.
&ensp;&ensp;&ensp;但是显然这样解释的话会给运行的程序增加压力,因为浪费了很多不必要的栈空间和CPU的运算资源.
&ensp;&ensp;&ensp;因此在优化后的生成代码的程序中,在处理到某个语法树的节点的时候,一旦发现整颗子树表示普通的常数表达式,我们构造出原来的常数表达式,使用Python自带的**eval()**函数求值即可,代码可以优化为:
``` python
(":=",6,None,temp_var_4)
(":=",temp_var_4,None,a)
```
###1.2 堆栈使用优化
&ensp;&ensp;&ensp;在堆栈空间无限的情况下,为每个局部表达式生成一个临时变量的空间是没有问题的.但是在c/c++中,堆栈资源有限(不过在测试程序中体现不出来),大量使用堆栈会使得在递归的时候更容易出现**爆栈**.以下方函数中的代码为例:
``` cpp
int a,b,c,d,e;
a=b+c+d+e;
```
&ensp;&ensp;&ensp;未经优化的话,程序会为(b+c), (b+c+d), (b+c+d+e)这三个表达式都额外开辟一份内存空间,如下方中间代码的示例:
``` python
("+",b,c,temp_var_12)
("+",temp_var_12,d,temp_var_8)
("+",temp_var_8,e,temp_var_4)
(":=",temp_var_4,None,a)
```
&ensp;&ensp;&ensp;观察可以看到,将代码分割为前两行和后两行,前两行中并未使用过***temp\_var\_4***,后两行中从未使用过***temp\_var\_12***.两者的使用范围没有交集,我们可以让这两个临时变量共享栈里面的同一个位置,优化后的中间代码如下所示:
``` python
("+",b,c,temp_var_8)
("+",temp_var_8,d,temp_var_4)
("+",temp_var_4,e,temp_var_8)
(":=",temp_var_8,None,a)
```
&ensp;&ensp;&ensp;具体的实现方法也很直观,我们设计了一个可以支持无限中间变量的**变量池**,每次需要使用中间变量的时候,从**变量池**中取出下标最小的中间变量,使用完后如果保证之后不再使用就归还回**变量池**.
&ensp;&ensp;&ensp;至于判定是否是"之后不再使用"的规则,对于任意一个四元式,我们记为`(op,oprand1,oprand2,dest)`,一般来说我们做的运算是`dest := oprand1 op oprand2` 之后dest有可能再参与之后的运算,因此`oprad1`和`oprand2`的生命周期到此结束,如果他们是临时变量的话就可以归还回**常量池**了.唯一一个例外的地方是赋值操作`(":=",oprand1,None,dest)`,进行赋值操作后,可能继续使用`oprand1`于是试图归还(不是临时变量就不能归还)`dest`.

---
## 二. 汇编代码优化
&ensp;&ensp;&ensp;编译器并未实现中间代码转成汇编代码的过程中进行优化,这里**汇编代码优化**是指生成汇编代码后直接针对汇编代码进行优化.
###2.1 "脏"寄存器赋值
&ensp;&ensp;&ensp;此处先解释"脏"(dirty)的概念.在汇编语言中主要的数据是存储在内存中的,但是几乎没有汇编指令支持多个操作数全是内存. 这两者之间的冲突需要CPU里面的寄存器进行过渡. 因此从某种程度上来说,寄存器是内存的拷贝. 但是这个时候又出现了一个情况, **寄存器内容发生改变的时候, 不会立即同步到内存中, 我们把这种和对应内存不一致的寄存器成为"脏的"**.
&ensp;&ensp;&ensp;显然对于不"脏"的寄存器,我们没有必要用对应的内存进行多次赋值,如:
``` x86asm
mov dword ptr [ebp-4+0],eax
mov eax,dword ptr [ebp-4+0]
```
&ensp;&ensp;&ensp;第二条指令是无论如何都不需要的,因此省略为:
``` x86asm
mov dword ptr [ebp-4],eax
```
###2.2 寄存器作为源(src)
&ensp;&ensp;&ensp;此过程不会减少代码行数,但是有两个作用:
 + 对汇编代码进行常数优化,因为寄存器总是比内存访问快
 + 能够提高之后写入内存的优化程度

&ensp;&ensp;&ensp;考虑这样若干条指令:
```
mov dword ptr [ebp-4+0],edi
mov eax,dword ptr [ebp-4+0]
```
&ensp;&ensp;&ensp;当寄存器和内存内用同步后,可以用寄存器替换内存,代码优化为:
```
mov dword ptr [ebp-4+0],edi
mov eax,edi
```
&ensp;&ensp;&ensp;同理,如下代码:
```
mov dword ptr [ebp-4+0],eax
push dword ptr [ebp-4+0]
```
&ensp;&ensp;&ensp;可以优化为:
```
mov dword ptr [ebp-4+0],eax
push eax
```

###2.3 省略部分写入内存
&ensp;&ensp;&ensp;进行了之前的优化后,仍然存在大量寄存器向内存的不必要赋值.不必要需要满足以下两个条件:
 + 是寄存器向临时变量赋值
 + 在block内,之后的指令中,不会再将临时变量的值作为源,或在作为源之前会再次被赋值

P.S. block定义为不含跳转指令也没有标签的连续的尽可能长的代码段,唯一的例外是block的最后一条指令可以是跳转指令.
&ensp;&ensp;&ensp;之所以只考虑一个block的情况是因为生成未优化的汇编代码时保证一个block里面一定是先对内存赋值,之后才可能将其作为源.
&ensp;&ensp;&ensp;考虑这样一个代码段:
``` x86asm
ll0:
	mov dword ptr [ebp-4+0],edi
	mov eax,edi
	cmp eax,0
	jnz ll1
	jmp ll2
ll1:
	;...
ll2:
	;...
```
&ensp;&ensp;&ensp;标签**ll0**到**jnz**指令(含)的代码构成一个block,但是我们可以明显看到第一条指令给`dword ptr [ebp-4+0]`赋值后就再也没有用到,而且地址的格式是`[ebp-x+y]`(我们保证这种形式的地址是中间变量),说明这是个编译器生成的中间变量,我们依据之前的规则可以省略第一条赋值指令.